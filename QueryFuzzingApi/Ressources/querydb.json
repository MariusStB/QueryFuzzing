[{"name":"php-sql-injection","author":"@0x4D5A","title":"SQL injection: A parameter is used in an insecure database API call.","description":"\nAn attacker controlled parameter is used in an insecure database API call.\n\nIf the parameter is not validated and sanitized, this is a SQL injection.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        // $_REQUEST[\"foo\"], $_GET[\"foo\"], $_POST[\"foo\"]\n        // are identifier (at the moment)\n        def source =\n          cpg.call.name(Operators.assignment).argument.code(\".*_(REQUEST|GET|POST).*\")\n\n        def sink = cpg.call.name(\"query\").filter(_.receiver.nonEmpty).argument\n\n        sink.reachableBy(source).l","tags":["remote-code-execution","default"],"language":"php","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"insecure-load-url-to-exec","author":"@ursachec","title":"Data from an insecure url load reaches `Runtime.getRuntime.exec` via JavaScript bridge.","description":"-","score":9.0,"traversal":{},"traversalAsString":"cpg =>\n        import overflowdb.traversal.Traversal\n        import io.shiftleft.semanticcpg.language.android._\n        import io.shiftleft.codepropertygraph.generated.nodes.{Call, Identifier}\n\n        def webViewsWithInsecureLoadUrlCalls =\n          cpg.webView.callsEnableJS.where(_.loadUrlCalls.filter { callNode =>\n            def httpLiterals =\n              callNode.method.literal.filter(_.code.stripPrefix(\"\\\"\").stripSuffix(\"\\\"\").startsWith(\"http:\"))\n            callNode.argument.reachableBy(httpLiterals).nonEmpty\n          })\n        val appUsesCleartextTraffic = cpg.appManifest.usesCleartextTraffic.nonEmpty\n        def exposedJavaScriptInterfaceObjects =\n          if (appUsesCleartextTraffic) webViewsWithInsecureLoadUrlCalls.addJavascriptInterfaceCalls.argument(1)\n          else Traversal.empty\n        val exposedJavaScriptInterfaceObjectNames = exposedJavaScriptInterfaceObjects.collect {\n          case ident: Identifier => ident.typeFullName\n          case call: Call        => call.typeFullName\n        }.l\n        def exposedJavaScriptInterfaceMethods =\n          cpg.method.exposedToJS\n            .where(_.typeDecl.filter { node => exposedJavaScriptInterfaceObjectNames.exists(_ == node.fullName) })\n        def runtimeExecCalls =\n          cpg.call.name(\"exec\").typeFullName(\"java.lang.Process\")\n        runtimeExecCalls.where(_.argument.reachableBy(exposedJavaScriptInterfaceMethods.parameter)).l","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.webkit.JavascriptInterface;\nimport android.widget.Toast;\n\nimport java.io.IOException;\n\npublic class JavaScriptBridge {\n    Context mContext;\n    JavaScriptBridge(Context c) {\n        mContext = c;\n    }\n\n    @JavascriptInterface\n    public int getAndroidVersion() {\n        return Build.VERSION.SDK_INT;\n    }\n\n    @JavascriptInterface\n    public void showToast(String text) {\n        Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n    }\n\n    // https://support.google.com/faqs/answer/9095419?hl=en\n    @JavascriptInterface\n    public void forgottenDebugFn(String cmd) {\n        String[] cmdArray = new String[3];\n        cmdArray[0] = \"sh\";\n        cmdArray[1] = \"-c\";\n        cmdArray[2] = cmd;\n\n        try {\n            Runtime.getRuntime().exec(cmdArray);\n        } catch (IOException e) {\n            System.out.print(\"error\");\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/JavaScriptBridge.java"},{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        JavaScriptBridge jsBridge = new JavaScriptBridge(this);\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(jsBridge, \"jsBridge\");\n\n        String url = \"http://phrack.org\";\n        webView.loadUrl(url);\n        finish();\n    }\n}\n","filename":"io/vroooom/vulnerableapp/MainActivityJava.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]],"negative":[[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.webkit.JavascriptInterface;\nimport android.widget.Toast;\n\nimport java.io.IOException;\n\npublic class JavaScriptBridge {\n    Context mContext;\n    JavaScriptBridge(Context c) {\n        mContext = c;\n    }\n\n    @JavascriptInterface\n    public int getAndroidVersion() {\n        return Build.VERSION.SDK_INT;\n    }\n\n    @JavascriptInterface\n    public void showToast(String text) {\n        Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n    }\n\n    // https://support.google.com/faqs/answer/9095419?hl=en\n    @JavascriptInterface\n    public void forgottenDebugFn(String cmd) {\n        String[] cmdArray = new String[3];\n        cmdArray[0] = \"sh\";\n        cmdArray[1] = \"-c\";\n        cmdArray[2] = cmd;\n\n        try {\n            Runtime.getRuntime().exec(cmdArray);\n        } catch (IOException e) {\n            System.out.print(\"error\");\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/JavaScriptBridge.java"},{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        JavaScriptBridge jsBridge = new JavaScriptBridge(this);\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(jsBridge, \"jsBridge\");\n\n        String url = \"https://lwn.net/\"; // no insecure url here\n        webView.loadUrl(url);\n        finish();\n    }\n}\n","filename":"io/vroooom/vulnerableapp/MainActivityJava.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.webkit.JavascriptInterface;\nimport android.widget.Toast;\n\nimport java.io.IOException;\n\npublic class JavaScriptBridge {\n    Context mContext;\n    JavaScriptBridge(Context c) {\n        mContext = c;\n    }\n\n    @JavascriptInterface\n    public int getAndroidVersion() {\n        return Build.VERSION.SDK_INT;\n    }\n\n    @JavascriptInterface\n    public void showToast(String text) {\n        Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n    }\n\n    // https://support.google.com/faqs/answer/9095419?hl=en\n    @JavascriptInterface\n    public void forgottenDebugFn(String cmd) {\n        String[] cmdArray = new String[3];\n        cmdArray[0] = \"sh\";\n        cmdArray[1] = \"-c\";\n        cmdArray[2] = cmd;\n\n        try {\n            Runtime.getRuntime().exec(cmdArray);\n        } catch (IOException e) {\n            System.out.print(\"error\");\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/JavaScriptBridge.java"},{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        JavaScriptBridge jsBridge = new JavaScriptBridge(this);\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(jsBridge, \"jsBridge\");\n\n        String url = \"http://phrack.net/\";\n        webView.loadUrl(url);\n        finish();\n    }\n}\n","filename":"io/vroooom/vulnerableapp/MainActivityJava.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.webkit.JavascriptInterface;\nimport android.widget.Toast;\n\nimport java.io.IOException;\n\npublic class JavaScriptBridge {\n    Context mContext;\n    JavaScriptBridge(Context c) {\n        mContext = c;\n    }\n\n    @JavascriptInterface\n    public int getAndroidVersion() {\n        return Build.VERSION.SDK_INT;\n    }\n\n    @JavascriptInterface\n    public void showToast(String text) {\n        Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n    }\n\n    // https://support.google.com/faqs/answer/9095419?hl=en\n    @JavascriptInterface\n    public void forgottenDebugFn(String cmd) {\n        String[] cmdArray = new String[3];\n        cmdArray[0] = \"sh\";\n        cmdArray[1] = \"-c\";\n        cmdArray[2] = cmd;\n\n        try {\n            // no call to exec here...\n            System.out.println(cmd);\n        } catch (IOException e) {\n            System.out.print(\"error\");\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/JavaScriptBridge.java"},{"content":"package io.vroooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        JavaScriptBridge jsBridge = new JavaScriptBridge(this);\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(jsBridge, \"jsBridge\");\n\n        String url = \"http://phrack.net/\";\n        webView.loadUrl(url);\n        finish();\n    }\n}\n","filename":"io/vroooom/vulnerableapp/MainActivityJava.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]]}},{"name":"call-to-exec","author":"@0x4D5A","title":"Dangerous function 'java.lang.Runtime.exec:java.lang.Process(java.lang.String)' used","description":"\n A call to the function `java.lang.Runtime.exec:java.lang.Process(java.lang.String)` \n could result in a potential remote code execution.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"java.lang.Runtime.exec\").callIn","tags":["badfn","default"],"language":"java","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"unsafe-crypto-hash-algo","author":"@DavidBakerEffendi","title":"Unsafe cryptographic hash algorithm used.","description":"\n MD5 and SHA-1 are considered weak and insecure; an attacker can easily use an MD5 collision to forge valid\n digital certificates or use dictionary/brute-force attacks to obtain passwords. Use SHA-256 instead.\n","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        def source = cpg.literal(\"\\\"MD5\\\"|\\\"SHA-1\\\"\")\n\n        def sink =\n          cpg.method.fullName(\"java.security.MessageDigest.getInstance.*\").parameter\n\n        sink.reachableBy(source).l","tags":["cryptography","default"],"language":"java","codeExamples":{"positive":["\nString algo = \"MD5\";\nMessageDigest md = MessageDigest.getInstance(algo);\n","\nString algo = \"SHA-1\";\nMessageDigest md = MessageDigest.getInstance(algo);\n"],"negative":["\nString algo = \"SHA-256\";\nMessageDigest md = MessageDigest.getInstance(algo);\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"low-pbe-key-iterations","author":"@DavidBakerEffendi","title":"Low number of iterations detected for password-based encryption.","description":"\n Do not use password-based encryption with iterations count less than 1000. You should use the maximum number\n of rounds which is tolerable, performance-wise, in your application.\n","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        def source = cpg.literal.code(\"\\\\d+\")\n\n        def sink =\n          cpg.method.fullName(\"javax.crypto.spec.PBEKeySpec.<init>.*\").parameter\n\n        sink.reachableBy(source).dedup.filter(f => Integer.parseInt(f.code) < 1000).l","tags":["cryptography","default"],"language":"java","codeExamples":{"positive":["\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA512\");\nSecretKey key = factory.generateSecret(new PBEKeySpec(password.toCharArray(), salt, 500, keyLength));\n"],"negative":["\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA512\");\nSecretKey key = factory.generateSecret(new PBEKeySpec(password.toCharArray(), salt, 4000, keyLength));\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"strncpy-no-null-term","author":"@fabsx00","title":"strncpy is used and no null termination is nearby","description":"\n Upon calling `strncpy` with a source string that is larger\n than the destination buffer, the destination buffer is not\n null-terminated by `strncpy` and there is no explicit\n null termination nearby. This is unproblematic if the\n buffer size is at least 1 larger than the size passed\n to `strncpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val allocations = cpg.method(\".*malloc$\").callIn.argument(1).l\n        cpg\n          .method(\"(?i)strncpy\")\n          .callIn\n          .map { c =>\n            (c.method, c.argument(1), c.argument(3))\n          }\n          .filter { case (method, dst, size) =>\n            dst.reachableBy(allocations).codeExact(size.code).nonEmpty &&\n            method.assignment\n              .where(_.target.arrayAccess.code(s\"${dst.code}.*\\\\[.*\"))\n              .source\n              .isLiteral\n              .code(\".*0.*\")\n              .isEmpty\n          }\n          .map(_._2)","tags":["strings","default"],"language":"c","codeExamples":{"positive":["\n\n// If src points to a string that is at least `asize` long,\n// then `ptr` will not be null-terminated after the `strncpy`\n// call.\nint bad() {\n  char *ptr = malloc(asize);\n  strncpy(ptr, src, asize);\n}\n\n"],"negative":["\n\n// Null-termination is ensured if we can only copy\n// less than `asize + 1` into the buffer\nint good() {\n  char *ptr = malloc(asize + 1);\n  strncpy(ptr, src, asize);\n}\n\n // Null-termination is also ensured if it is performed\n // explicitly\nint alsogood() {\n  char *ptr = malloc(asize);\n  strncpy(ptr, src, asize);\n  ptr[asize -1] = '\\0';\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"ineffective-certificate-check","author":"@maltek","title":"Ineffective Certificate Validation: The validation result is always positive","description":"\nA certificate validation function is implemented as a function that only consists of a prologue where local\nvariables are initialized to arguments, followed by a (positive) return statement.\n","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        val validators = Map(\n          // javax.net.ssl.HostnameVerifier\n          \"verify\" -> \"boolean(java.lang.String,javax.net.ssl.SSLSession)\",\n          // javax.net.ssl.X509ExtendedTrustManager\n          \"checkClientTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket)\",\n          \"checkClientTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine)\",\n          \"checkServerTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket)\",\n          \"checkServerTrusted\" -> \"void(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine)\"\n        )\n\n        // skip over arguments getting copied to local variables\n        def isPrologue(node: nodes.CfgNode): Boolean = node match {\n          case id: nodes.Identifier =>\n            id.refsTo.forall(_.isInstanceOf[nodes.Local])\n          case c: nodes.Call =>\n            c.methodFullName == Operators.assignment && c.argument.forall(isPrologue)\n          case _ => false\n        }\n        def skipPrologue(node: nodes.CfgNode): Traversal[nodes.CfgNode] =\n          Traversal.fromSingle(node).repeat(_.cfgNext)(_.until(_.filter(!isPrologue(_))))\n\n        cpg.method\n          .nameExact(validators.keys.toSeq: _*)\n          .signatureExact(validators.values.toSeq: _*)\n          .cfgFirst\n          .flatMap(skipPrologue)\n          .filter {\n            case lit: nodes.Literal =>\n              lit.code == \"1\" && lit.cfgNext\n                .forall(_.isInstanceOf[nodes.Return])\n            case _: nodes.Return => true\n            case _               => false\n          }","tags":["badimpl","default"],"language":"java","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"unchecked-read-recv-malloc","author":"@fabsx00","title":"Unchecked read/recv/malloc","description":"\nThe return value of a read/recv/malloc call is not checked directly and\nthe variable it has been assigned to (if any) does not\noccur in any check within the caller.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        implicit val noResolve: NoResolve.type = NoResolve\n        cpg\n          .method(\"(?i)(read|recv|malloc)\")\n          .callIn\n          .returnValueNotChecked","tags":["default"],"language":"c","codeExamples":{"positive":["\n\nvoid unchecked_read() {\n  read(fd, buf, sizeof(buf));\n}\n\nvoid checks_something_else() {\n  int nbytes = read(fd, buf, sizeof(buf));\n  if( foo != sizeof(buf)) {\n\n  }\n}\n\n"],"negative":["\n\nvoid checked_after_assignment() {\n  int nbytes = read(fd, buf, sizeof(buf));\n  if( nbytes != sizeof(buf)) {\n\n  }\n}\n\nvoid immediately_checked() {\n  if ( (read(fd, buf, sizeof(buf))) != sizeof(buf)) {\n\n  }\n}\n\nint notCheckedButDirectlyReturned() {\n  return read(fd, buf, sizeof(buf));\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"shell-exec","author":"@0x4D5A","title":"Shell exec: A parameter is used in an insecure `shell-exec` call.","description":"\nAn attacker controlled parameter is used in an insecure `shell-exec` call.\n\nIf the parameter is not validated and sanitized, this is a remote code execution.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        // $_REQUEST[\"foo\"], $_GET[\"foo\"], $_POST[\"foo\"]\n        // are identifier (at the moment)\n        def source =\n          cpg.call.name(Operators.assignment).argument.code(\".*_(REQUEST|GET|POST).*\")\n\n        def sink = cpg.call.name(\"shell_exec\").argument\n\n        sink.reachableBy(source).l","tags":["remote-code-execution","default"],"language":"php","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-strcpy-ghidra","author":"@tuxology","title":"Dangerous functions `strcpy` or `strncpy` used","description":"\n Avoid `strcpy` or `strncpy` function. `strcpy` does not check buffer\n lengths.\n A possible mitigation could be `strncpy` which could prevent\n buffer overflows but does not null-terminate strings leading to\n memory corruption. A secure alternative (on BSD) is `strlcpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)(strcpy|strncpy)\").callIn","tags":["badfn"],"language":"ghidra","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"signed-left-shift","author":"@maltek","title":"Signed Shift May Cause Undefined Behavior","description":"\nSigned integer overflow is undefined behavior. Shifts of signed values to the\nleft are very prone to overflow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.call\n          .nameExact(Operators.shiftLeft, Operators.assignmentShiftLeft)\n          .where(_.argument(1).typ.fullNameExact(\"int\", \"long\"))\n          .filterNot(_.argument.isLiteral.size == 2)","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nvoid bad1(int val) {\n  val <<= 24;\n}\n\nvoid bad2(int val) {\n  255 << val;\n}\n\nvoid bad3(int val) {\n  val << val;\n}\n"],"negative":["\n\nvoid good(unsigned int val) {\n  255 << 24; // we ignore signed shift with two literals\n  val <<= 24;\n  val << val;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"manifest-backup-enabled","author":"@ursachec","title":"Backups enabled in Android Manifest File","description":"\nBackup flag is set to true in AndroidManifest.xml which means that the application data can be retrieved via adb.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        import io.joern.semanticcpg.utils.SecureXmlParsing\n\n        val androidUri = \"http://schemas.android.com/apk/res/android\"\n        cpg.configFile\n          .filter(_.name.endsWith(\"AndroidManifest.xml\"))\n          .where { config =>\n            config.content\n              .flatMap(SecureXmlParsing.parseXml)\n              .filter(_.label == \"manifest\")\n              .flatMap(_.child)\n              .filter(_.label == \"application\")\n              .filter { node =>\n                val isAllowBackup = node.attribute(androidUri, \"allowBackup\")\n                isAllowBackup match {\n                  case Some(n) => n.toString == \"true\"\n                  case None    => false\n                }\n              }\n          }","tags":["android","misconfiguration"],"language":"android","codeExamples":{"positive":["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.slimandroid\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:label=\"SlimAndroid\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.AppCompat\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>"],"negative":["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.slimandroid\">\n\n    <application\n        android:allowBackup=\"false\"\n        android:label=\"SlimAndroid\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.AppCompat\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"tap-jacking","author":"@ursachec","title":"Tap Jacking: target SDK <23 specified in `build.gradle` ","description":"\nAndroid apps targeting API levels 22 and lower have the SYSTEM_ALERT_WINDOW permission enabled by default.\nThis allows apps to draw overlays over other apps. Attackers can use this option to create an overlay that\nwould essentially hijack user taps and use it to obtain sensitive user information.","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        def groovyBuildGradleFiles = cpg.configFile.name(\".*build.gradle\")\n        val targetSdkVersionMatch  = \"\"\"^[^t]+targetSdk[^0-9]+(\\d+)\"\"\".r\n        val firstSecureSdkVersion  = 23\n        groovyBuildGradleFiles.filter { gradleFile =>\n          gradleFile.content\n            .split('\\n')\n            .exists { line =>\n              targetSdkVersionMatch\n                .findAllIn(line)\n                .matchData\n                .exists { m =>\n                  m.groupCount > 0 && m.group(1).toInt < firstSecureSdkVersion\n                }\n            }\n        }","tags":["android","misconfiguration"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"fun main() = println(0xbadf00d)","filename":"SomeActivity.kt"},{"content":"\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n}\n\nandroid {\n    compileSdk 22\n    defaultConfig {\n        applicationId \"com.example.slimandroid\"\n        minSdk 22\n        targetSdk 22\n        versionCode 1\n        versionName \"1.0\"\n    }\n}\n","filename":"build.gradle"}]],"negative":[[{"content":"fun main() = println(0xbadf00d)","filename":"SomeActivity.kt"},{"content":"\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n}\n\nandroid {\n    compileSdk 23\n    defaultConfig {\n        applicationId \"com.example.slimandroid\"\n        minSdk 23\n        targetSdk 23\n        versionCode 1\n        versionName \"1.0\"\n    }\n}\n","filename":"build.gradle"}]]}},{"name":"vuln-prng-android-v16_18","author":"@DavidBakerEffendi","title":"Vulnerable underlying PRNG used on currently set version of Android","description":"\nThe underlying PRNG is vulnerable on Android v16-18. If the application is implemented by utilizing\norg.webkit package and a key exchange scheme is RSA, the PreMasterSecret of the first SSL session\ncan be recovered using the restored PRNG states.\n\nFor more information, see \"Predictability of Android OpenSSL's Pseudo random number generator\" by S.H. Kim \net. al.\n","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        def groovyBuildGradleFiles = cpg.configFile.name(\".*build.gradle\")\n\n        val targetSdkVersionMatch = \"\"\"^[^t]+minSdk[^0-9]+(\\d+)\"\"\".r\n        val insecureSdkVersionMin = 16\n        val insecureSdkVersionMax = 18\n        def satisfiesConfig = groovyBuildGradleFiles.filter { gradleFile =>\n          gradleFile.content\n            .split('\\n')\n            .exists { line =>\n              targetSdkVersionMatch\n                .findAllIn(line)\n                .matchData\n                .exists { m =>\n                  m.groupCount > 0 &&\n                  m.group(1).toInt >= insecureSdkVersionMin\n                  m.group(1).toInt <= insecureSdkVersionMax\n                }\n            }\n        }\n\n        def source         = cpg.literal(\"\\\".*PRNG.*\\\"\")\n        def sink           = cpg.call.code(\".*SecureRandom.getInstance.*\")\n        def defaultSecRand = cpg.call.methodFullNameExact(\"java.security.SecureRandom.<init>:void()\")\n        if (\n          (defaultSecRand.nonEmpty || sink.reachableBy(source).nonEmpty) &&\n          satisfiesConfig.nonEmpty\n        )\n          satisfiesConfig\n        else\n          Traversal.empty","tags":["android","cryptography","misconfiguration"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"sql-injection","author":"@0x4D5A","title":"SQL injection: A parameter is used in an insecure database API call.","description":"\nAn attacker controlled parameter is used in an insecure database API call.\n\nIf the parameter is not validated and sanitized, this is a SQL injection.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        def source =\n          cpg.method\n            .where(_.methodReturn.evalType(\"org.springframework.web.servlet.ModelAndView\"))\n            .parameter\n\n        def sink = cpg.method.name(\"query\").parameter.order(1)\n\n        sink.reachableBy(source).l","tags":["sql-injection","default"],"language":"java","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"socket-send","author":"@fabsx00","title":"Unchecked call to send","description":"\n When calling `send`, the return value must be checked to determine\n if the send operation was successful and how many bytes were\n transmitted.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        implicit val noResolve: NoResolve.type = NoResolve\n        cpg\n          .method(\"send\")\n          .filter(_.parameter.size == 4)\n          .callIn\n          .returnValueNotChecked","tags":["default","posix"],"language":"c","codeExamples":{"positive":["\n\nvoid return_not_checked(int sockfd, void *buf, size_t len, int flags) {\n    send(sockfd, buf, len, flags);\n}\n\n"],"negative":["\n\nvoid return_checked(int sockfd, void *buf, size_t len, int flags) {\n    if (send(sockfd, buf, len, flags) <= 0) {\n        // Do something\n    }\n}\n\n","\n\nvoid return_var_checked(int sockfd, void *buf, size_t len, int flags) {\n    ssize_t ret = send(sockfd, buf, len, flags);\n\n    if (ret <= 0) {\n        // Do something\n    }\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"unzip-directory-traversal","author":"@ursachec","title":"Zip entries not checked before unzipping","description":"-","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val zipEntryTypeFullNames =\n          List(\"org.apache.commons.compress.archivers.ArchiveEntry\", \"java.util.zip.ZipEntry\")\n        def zipEntryParams =\n          cpg.method.parameter.typeFullNameExact(zipEntryTypeFullNames: _*)\n        def fileOutStreamInit =\n          cpg.method.fullNameExact(\"java.io.FileOutputStream.<init>:void(java.io.File)\").callIn\n        def pathStartsWithCalls =\n          cpg.method.fullNameExact(\"java.nio.file.Path.startsWith:boolean(java.nio.file.Path)\").callIn\n\n        def uncheckedZipEntryParameters = zipEntryParams.filter { param =>\n          pathStartsWithCalls.argument(0).reachableByFlows(param).isEmpty\n        }\n        fileOutStreamInit.filter { call =>\n          call.argument.reachableByFlows(uncheckedZipEntryParameters).nonEmpty\n        }","tags":["path-traversal","android"],"language":"kotlin","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"\nimport java.io.*\nimport java.nio.file.Paths\nimport java.util.zip.ZipFile\n\nfun unzip(zipFilePath: File, destDirectory: String) {\n    val BUFFER_SIZE = 4096\n    ZipFile(zipFilePath).use { zip ->\n        zip.entries().asSequence().forEach { entry ->\n            val zipEntryInputStream = zip.getInputStream(entry)\n\n            val fileForEntry = File(destDirectory, entry.getName())\n            val entryOutStream = FileOutputStream(fileForEntry)\n\n            val bos = BufferedOutputStream(entryOutStream)\n            val bytesIn = ByteArray(BUFFER_SIZE)\n            var read: Int\n            while (zipEntryInputStream.read(bytesIn).also { read = it } != -1) {\n                bos.write(bytesIn, 0, read)\n            }\n            bos.close()\n\n            zipEntryInputStream.close()\n        }\n    }\n}\n\nfun main() {\n    // to make a slippery zip:\n    // 1. create a file /tmp/zip/extract/slip.txt\n    // 2. inside /tmp/zip/extract run `zip slip.zip ../slip.txt`\n    val zp = File(\"/tmp/zip/slip.zip\")\n    unzip(zp, \"/tmp/zip/extract\")\n}\n","filename":"Positive.kt"}]],"negative":[[{"content":"\nimport java.io.*\nimport java.nio.file.Paths\nimport java.util.zip.ZipFile\n\nfun unzip(zipFilePath: File, destDirectory: String) {\n    val BUFFER_SIZE = 4096\n    ZipFile(zipFilePath).use { zip ->\n        zip.entries().asSequence().forEach { entry ->\n            val zipEntryInputStream = zip.getInputStream(entry)\n\n            val fileForEntry = File(destDirectory, entry.getName())\n            if (!fileForEntry.toPath().normalize().startsWith(Paths.get(destDirectory))) {\n                throw Exception(\"Whatever's in this zip, it's not good.\")\n            }\n            val entryOutStream = FileOutputStream(fileForEntry)\n\n            val bos = BufferedOutputStream(entryOutStream)\n            val bytesIn = ByteArray(BUFFER_SIZE)\n            var read: Int\n            while (zipEntryInputStream.read(bytesIn).also { read = it } != -1) {\n                bos.write(bytesIn, 0, read)\n            }\n            bos.close()\n\n            zipEntryInputStream.close()\n        }\n    }\n}\n","filename":"Negative.kt"}]]}},{"name":"fragment-injection","author":"@ursachec","title":"Attackers can load fragments that should be private","description":"-","score":7.0,"traversal":{},"traversalAsString":"cpg =>\n        def groovyBuildGradleFiles                                  = cpg.configFile.name(\".*build.gradle\")\n        val targetSdkVersionMatch                                   = \"\"\"^[^t]+targetSdk[^0-9]+(\\d+)\"\"\".r\n        val minimumAndroidSdkVersionWhereNoAdditionalChecksRequired = 19\n        groovyBuildGradleFiles.filter { gradleFile =>\n          gradleFile.content\n            .split('\\n')\n            .exists { line =>\n              targetSdkVersionMatch\n                .findAllIn(line)\n                .matchData\n                .exists { m =>\n                  m.groupCount > 0 && m.group(1).toInt < minimumAndroidSdkVersionWhereNoAdditionalChecksRequired\n                }\n            }\n        }","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"fun main() = println(0xbadf00d)","filename":"SomeActivity.kt"},{"content":"\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n}\n\nandroid {\n    compileSdk 32\n    defaultConfig {\n        applicationId \"com.example.slimandroid\"\n        minSdk 23\n        targetSdk 18\n        versionCode 1\n        versionName \"1.0\"\n    }\n}\n","filename":"build.gradle"}]],"negative":[[{"content":"fun main() = println(0xbadf00d)","filename":"SomeActivity.kt"},{"content":"\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n}\n\nandroid {\n    compileSdk 32\n    defaultConfig {\n        applicationId \"com.example.slimandroid\"\n        minSdk 23\n        targetSdk 19\n        versionCode 1\n        versionName \"1.0\"\n    }\n}\n","filename":"build.gradle"}]]}},{"name":"too-many-params","author":"@fabsx00","title":"Number of parameters larger than 4","description":"This query identifies functions with more than 4 formal parameters","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.parameter.size > n).nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint too_many_params(int a, int b, int c, int d, int e) {\n\n}\n\n"],"negative":["\n\nvoid good(int a, int b, int c, int d) {\n\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"too-high-complexity","author":"@fabsx00","title":"Cyclomatic complexity higher than 4","description":"This query identifies functions with a cyclomatic complexity higher than 4","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.controlStructure.size > n).nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint high_cyclomatic_complexity(int x) {\n  while(true) {\n    for(int i = 0; i < 10; i++) {\n    }\n    if(foo()) {}\n  }\n  if (x > 10) {\n    for(int i = 0; i < 10; i++) {\n\n     }\n  }\n}\n\n"],"negative":["\n\nvoid good(int x, int y) {\n    if (x > 0) {/* Stuff */ } else { /* Stuff */ }\n    if (y > 0) {/* Stuff */ } else { /* Stuff */ }\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"too-long","author":"@fabsx00","title":"More than 1000 lines","description":"This query identifies functions that are more than 1000 lines long","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.numberOfLines > n).nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_many_lines(int x) {\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n  x++;\n}\n\n"],"negative":["\n\nint func_with_few_lines(int x) {\n  x++;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"multiple-returns","author":"@fabsx00","title":"Multiple returns","description":"This query identifies functions with more than one return","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.ast.isReturn.l.size > 1).nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_multiple_returns (int x) {\n  if (x > 10) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n"],"negative":["\n\nint func_without_multiple_returns() {\n  return 0;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"too-many-loops","author":"@fabsx00","title":"More than 4 loops","description":"This query identifies functions with more than 4 loops","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal\n          .filter(\n            _.ast.isControlStructure\n              .controlStructureType(\"(FOR|DO|WHILE)\")\n              .size > n\n          )\n          .nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint high_number_of_loops () {\n  for(int i = 0; i < 10; i++){\n  }\n  int j = 0;\n  do {\n    j++\n  } while(j < 10);\n  while(foo()) {}\n  while(bar()){}\n}\n"],"negative":["\nint not_many_loops() {\n  while (true) {\n    // Do something\n  }\n}\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"too-nested","author":"@fabsx00","title":"Nesting level higher than 3","description":"This query identifies functions with a nesting level higher than 3","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.depth(_.isControlStructure) > n).nameNot(\"<global>\")","tags":["metrics"],"language":"c","codeExamples":{"positive":["\n\nint func_with_nesting_level_of_3(int foo, int bar) {\n  if (foo > 10) {\n    if (bar > foo) {\n      for(int i = 0; i < bar ;i++) {\n\n      }\n    }\n  }\n}\n\n"],"negative":["\n\nint func_with_nesting_level_of_1(int foo) {\n  if (foo > 10) {\n    // Do something\n  }\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"external-storage-to-dex-classloader","author":"@ursachec","title":"Data from external storage ends up in dex classloader, leading to code execution.","description":"-","score":9.0,"traversal":{},"traversalAsString":"cpg =>\n        import overflowdb.traversal.Traversal\n        import io.shiftleft.semanticcpg.language.android._\n        import io.joern.x2cpg.Defines.ConstructorMethodName\n\n        def externalStorageReads =\n          if (cpg.appManifest.hasReadExternalStoragePermission.nonEmpty)\n            cpg.getExternalStorageDir\n          else Traversal.empty\n        def dexClassLoadersWithExternalStorageInit =\n          cpg.dexClassLoader\n            .where(\n              _.method.call\n                .nameExact(ConstructorMethodName)\n                .where(_.argument(0).isIdentifier.typeFullNameExact(\"dalvik.system.DexClassLoader\"))\n                .where(_.argument(1).reachableBy(externalStorageReads))\n            )\n        def loadClassCalls =\n          dexClassLoadersWithExternalStorageInit.referencingIdentifiers.inCall.nameExact(\"loadClass\")\n        def reflectInvoke = cpg.call.methodFullNameExact(\n          \"java.lang.reflect.Method.invoke:java.lang.Object(java.lang.Object,java.lang.Object[])\"\n        )\n        reflectInvoke.where(_.argument(1).reachableBy(loadClassCalls))","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.Manifest;\nimport android.content.pm.PackageManager;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\n\nimport dalvik.system.DexClassLoader;\n\npublic class DexClassLoaderActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, 1234);\n        } else {\n            String externalStorageRoot = Environment.getExternalStorageDirectory().toString();\n            listFiles(externalStorageRoot);\n\n            String pathToDex = externalStorageRoot + \"/Beep.zip\";\n            loadDexFromPath(pathToDex);\n        }\n    }\n\n    private void listFiles(String path) {\n        Log.d(\"Files\", \"Path: \" + path);\n        File directory = new File(path);\n        File[] files = directory.listFiles();\n        Log.d(\"Files\", \"Size: \"+ files.length);\n        for (int i = 0; i < files.length; i++) {\n            Log.d(\"Files\", \"FileName:\" + files[i].getName());\n        }\n    }\n\n    private void loadDexFromPath(String path) {\n        try {\n            File tmpDir = getDir(\"dex\", 0);\n\n            DexClassLoader classloader = new DexClassLoader(path, tmpDir.getAbsolutePath(), null, this.getClass().getClassLoader());\n            final Class<Object> classToLoad = (Class<Object>) classloader.loadClass(\"Beep\");\n            final Object myInstance  = classToLoad.newInstance();\n            final Method returnString = classToLoad.getMethod(\"getName\");\n            String result = (String) returnString.invoke(myInstance);\n            Log.e(\"Test\", result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/DexClassLoaderActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        android:requestLegacyExternalStorage=\"true\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]],"negative":[[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.Manifest;\nimport android.content.pm.PackageManager;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\n\nimport dalvik.system.DexClassLoader;\n\npublic class DexClassLoaderActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, 1234);\n        } else {\n            String externalStorageRoot = Environment.getExternalStorageDirectory().toString();\n            listFiles(externalStorageRoot);\n\n            String pathToDex = externalStorageRoot + \"/Beep.zip\";\n            loadDexFromPath(pathToDex);\n        }\n    }\n\n    private void listFiles(String path) {\n        Log.d(\"Files\", \"Path: \" + path);\n        File directory = new File(path);\n        File[] files = directory.listFiles();\n        Log.d(\"Files\", \"Size: \"+ files.length);\n        for (int i = 0; i < files.length; i++) {\n            Log.d(\"Files\", \"FileName:\" + files[i].getName());\n        }\n    }\n\n    private void loadDexFromPath(String path) {\n        try {\n            File tmpDir = getDir(\"dex\", 0);\n\n            DexClassLoader classloader = new DexClassLoader(path, tmpDir.getAbsolutePath(), null, this.getClass().getClassLoader());\n            final Class<Object> classToLoad = (Class<Object>) classloader.loadClass(\"Beep\");\n            final Object myInstance  = classToLoad.newInstance();\n            final Method returnString = classToLoad.getMethod(\"getName\");\n            String result = (String) returnString.invoke(myInstance);\n            Log.e(\"Test\", result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/DexClassLoaderActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package io.vroooom.vulnerableapp;\n\nimport android.Manifest;\nimport android.content.pm.PackageManager;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\n\nimport dalvik.system.DexClassLoader;\n\npublic class DexClassLoaderActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, 1234);\n        } else {\n            String somePath = \"/an/app/internal/path\";\n            listFiles(somePath);\n            loadDexFromPath(somePath);\n        }\n    }\n\n    private void listFiles(String path) {\n        Log.d(\"Files\", \"Path: \" + path);\n        File directory = new File(path);\n        File[] files = directory.listFiles();\n        Log.d(\"Files\", \"Size: \"+ files.length);\n        for (int i = 0; i < files.length; i++) {\n            Log.d(\"Files\", \"FileName:\" + files[i].getName());\n        }\n    }\n\n    private void loadDexFromPath(String path) {\n        try {\n            File tmpDir = getDir(\"dex\", 0);\n\n            DexClassLoader classloader = new DexClassLoader(path, tmpDir.getAbsolutePath(), null, this.getClass().getClassLoader());\n            final Class<Object> classToLoad = (Class<Object>) classloader.loadClass(\"Beep\");\n            final Object myInstance  = classToLoad.newInstance();\n            final Method returnString = classToLoad.getMethod(\"getName\");\n            String result = (String) returnString.invoke(myInstance);\n            Log.e(\"Test\", result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","filename":"io/vroooom/vulnerableapp/DexClassLoaderActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n\n        <activity\n            android:name=\".MainActivityJava\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]]}},{"name":"malloc-memcpy-int-overflow","author":"@fabsx00","title":"Dangerous copy-operation into heap-allocated buffer","description":"-","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val src =\n          cpg.method(\".*malloc$\").callIn.where(_.argument(1).arithmetic).l\n\n        cpg.method(\"(?i)memcpy\").callIn.l.filter { memcpyCall =>\n          memcpyCall\n            .argument(1)\n            .reachableBy(src)\n            .where(_.inAssignment.target.codeExact(memcpyCall.argument(1).code))\n            .whereNot(_.argument(1).codeExact(memcpyCall.argument(3).code))\n            .hasNext\n        }","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nint vulnerable(size_t len, char *src) {\n  char *dst = malloc(len + 8);\n  memcpy(dst, src, len + 7);\n}\n\n"],"negative":["\n\nint non_vulnerable(size_t len, char *src) {\n char *dst = malloc(len + 8);\n memcpy(dst, src,len + 8);\n}\n\nint non_vulnerable2(size_t len, char *src) {\n char *dst = malloc( some_size );\n assert(dst);\n memcpy(dst, src, some_size );\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"strlen-truncation","author":"@fabsx00","title":"Truncation in assignment involving `strlen` call","description":"\nThe return value of `strlen` is stored in a variable that is known\nto be of type `int` as opposed to `size_t`. `int` is only 32 bit\nwide on many 64 bit platforms, and thus, this may result in a\ntruncation.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .name(\"(?i)strlen\")\n          .callIn\n          .inAssignment\n          .target\n          .evalType(\"(g?)int\")","tags":["integers","default"],"language":"c","codeExamples":{"positive":["\n\nint vulnerable(char *str) {\n  int len;\n  len = strlen(str);\n}\n\n"],"negative":["\n\nint non_vulnerable(char *str) {\n  size_t len;\n  len = strlen(str);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"constant-array-access-no-check","author":"@fabsx00","title":"Array access at fixed offset but sufficient length check not determined","description":"\n\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.arrayAccess\n          .filter { access =>\n            val arrName = access.simpleName\n            arrName.nonEmpty && !arrName.forall(x => access.method.local.nameExact(x).nonEmpty)\n          }\n          .usesConstantOffset\n          .flatMap { arrayAccess =>\n            val lenFields =\n              potentialLengthFields(arrayAccess, arrayAccess.method)\n            if (lenFields.nonEmpty) {\n              List((arrayAccess, lenFields))\n            } else {\n              List()\n            }\n          }\n          .collect {\n            case (arrayAccess, lenFields) if !checked(arrayAccess, lenFields) =>\n              arrayAccess\n          }","tags":["default"],"language":"c","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"xss-servlet","author":"@maltek","title":"Reflected Cross-Site Scripting: Servlet Returns HTTP Input in Response","description":"\nA servlet returns a URL parameter as part of the response.\n\nUnless the parameter is escaped or validated in-between, this is a reflected XSS vulnerability.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        def source =\n          cpg.call.methodFullNameExact(\n            \"javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)\"\n          )\n\n        def responseWriter =\n          cpg.call.methodFullNameExact(\"javax.servlet.http.HttpServletResponse.getWriter:java.io.PrintWriter()\")\n\n        def sinks =\n          cpg.call\n            .methodFullNameExact(\"java.io.PrintWriter.println:void(java.lang.String)\")\n            .where(_.argument(0).reachableBy(responseWriter))\n\n        sinks.where(_.argument(1).reachableBy(source))","tags":["xss","default"],"language":"java","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"usage-of-nop-trust-manager","author":"@ursachec","title":"NOP trust manager used to initialize SSL context","description":"Traffic sent using this context can be intercepted by attackers on the same network","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        val nopTrustManagerFullNames =\n          cpg.typeDecl\n            .isExternal(false)\n            .filter(_.inheritsFromTypeFullName.contains(\"javax.net.ssl.X509TrustManager\"))\n            .filter { node =>\n              node.method.nameExact(\"checkClientTrusted\").block.expressionDown.isEmpty ||\n              node.method.nameExact(\"checkServerTrusted\").block.expressionDown.isEmpty\n            }\n            .fullName\n            .toSeq\n        def nopTrustManagersAllocs =\n          cpg.method.fullNameExact(Operators.alloc).callIn.typeFullNameExact(nopTrustManagerFullNames: _*)\n        def sslCtxInitCalls = cpg.method\n          .fullNameExact(\"javax.net.ssl.SSLContext.init:void(kotlin.Array,kotlin.Array,java.security.SecureRandom)\")\n          .callIn\n        sslCtxInitCalls.filter { call =>\n          call.argument(2).reachableBy(nopTrustManagersAllocs).nonEmpty\n        }","tags":["android","insecure-network-traffic"],"language":"kotlin","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"\npackage mypkg\n\nimport javax.net.ssl.SSLContext\nimport javax.net.ssl.TrustManager\nimport javax.net.ssl.X509TrustManager\n\nclass NOPTrustManager : X509TrustManager {\n    override fun getAcceptedIssuers(): Array<X509Certificate>? = null\n    override fun checkClientTrusted(certs: Array<X509Certificate>, authType: String) {}\n    override fun checkServerTrusted(certs: Array<X509Certificate>, authType: String) {}\n}\n\nfun main() {\n    val acceptAllTrustManager = NOPTrustManager()\n    val trustAllCerts = arrayOf<TrustManager>(acceptAllTrustManager)\n    val sslContext = SSLContext.getInstance(\"SSL\")\n    sslContext.init(null, trustAllCerts, java.security.SecureRandom())\n}\n","filename":"App.kt"}]],"negative":[[{"content":"\npackage mypkg\n\nimport javax.net.ssl.SSLContext\nimport javax.net.ssl.TrustManager\nimport javax.net.ssl.X509TrustManager\n\n# nop trust manager defined but not used\nclass NOPTrustManager : X509TrustManager {\n    override fun getAcceptedIssuers(): Array<X509Certificate>? = null\n    override fun checkClientTrusted(certs: Array<X509Certificate>, authType: String) {}\n    override fun checkServerTrusted(certs: Array<X509Certificate>, authType: String) {}\n}\n","filename":"App.kt"}]]}},{"name":"file-operation-race","author":"@maltek","title":"Two file operations on the same path can act on different files","description":"\nTwo subsequent file operations are performed on the same path. Depending on the permissions\non this path, an attacker can exploit a race condition and replace the file or directory\nthe path refers to between these calls.\nUse file operations based on file descriptor/pointer/handles instead of paths to avoid this issue.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        val operations: Map[String, Seq[Int]] = Map(\n          \"access\"     -> Seq(1),\n          \"chdir\"      -> Seq(1),\n          \"chmod\"      -> Seq(1),\n          \"chown\"      -> Seq(1),\n          \"creat\"      -> Seq(1),\n          \"faccessat\"  -> Seq(2),\n          \"fchmodat\"   -> Seq(2),\n          \"fopen\"      -> Seq(1),\n          \"fstatat\"    -> Seq(2),\n          \"lchown\"     -> Seq(1),\n          \"linkat\"     -> Seq(2, 4),\n          \"link\"       -> Seq(1, 2),\n          \"lstat\"      -> Seq(1),\n          \"mkdirat\"    -> Seq(2),\n          \"mkdir\"      -> Seq(1),\n          \"mkfifoat\"   -> Seq(2),\n          \"mkfifo\"     -> Seq(1),\n          \"mknodat\"    -> Seq(2),\n          \"mknod\"      -> Seq(1),\n          \"openat\"     -> Seq(2),\n          \"open\"       -> Seq(1),\n          \"readlinkat\" -> Seq(2),\n          \"readlink\"   -> Seq(1),\n          \"renameat\"   -> Seq(2, 4),\n          \"rename\"     -> Seq(1, 2),\n          \"rmdir\"      -> Seq(1),\n          \"stat\"       -> Seq(1),\n          \"unlinkat\"   -> Seq(2),\n          \"unlink\"     -> Seq(1)\n        )\n\n        def fileCalls(calls: Traversal[Call]) =\n          calls.nameExact(operations.keys.toSeq: _*)\n\n        def fileArgs(c: Call) =\n          c.argument.whereNot(_.isLiteral).argumentIndex(operations(c.name): _*)\n\n        fileCalls(cpg.call)\n          .filter(call => {\n            val otherCalls = fileCalls(call.method.ast.isCall).filter(_ != call)\n            val argsForOtherCalls =\n              otherCalls.flatMap(c => fileArgs(c)).code.toSet\n\n            fileArgs(call).code.exists(arg => argsForOtherCalls.contains(arg))\n          })","tags":["race-condition","default"],"language":"c","codeExamples":{"positive":["\n\nvoid insecure_race(char *path) {\n    chmod(path, 0);\n    rename(path, \"/some/new/path\");\n}\n\n"],"negative":["\n\nvoid secure_handle(char *path) {\n    FILE *file = fopen(path, \"r\");\n    fchown(fileno(file), 0, 0);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"root-detection-via-file-checks","author":"@ursachec","title":"App attempts to detect rooting via file checks","description":"-","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        val superUserCheckPathSuffixes = List(\"Superuser.apk\", \"superuser.apk\", \"/su\")\n        def pathsToSuperUserSuffixes =\n          cpg.literal.filter(_.code.contains('/')).filter { node =>\n            superUserCheckPathSuffixes.exists { ending =>\n              node.code.stripSuffix(\"\\\"\").stripSuffix(\"\\'\").endsWith(ending)\n            }\n          }\n        def fileExistsCalls = cpg.call.methodFullNameExact(\"java.io.File.exists:boolean()\")\n        fileExistsCalls.where(_.argument.reachableBy(pathsToSuperUserSuffixes)).method.where(_.caller)","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"\npackage no.such.pkg\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport java.io.File\n\nclass RootDetectionActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        if (isRooted()) { println(\"Device is rooted\") }\n    }\n\n    fun isRooted(): Boolean {\n      val paths = arrayOf(\"/system/app/Superuser/Superuser.apk\", \"/system/app/Superuser.apk\",\"/sbin/su\", \"/system/bin/su\", \"/system/xbin/su\", \"/data/local/xbin/su\", \"/data/local/bin/su\", \"/system/sd/xbin/su\", \"/system/bin/failsafe/su\", \"/data/local/su\", \"/su/bin/su\", \"re.robv.android.xposed.installer-1.apk\",\"/data/app/eu.chainfire.supersu-1/base.apk\");\n      for(path in paths) {\n          val f = File(path)\n          if (f.exists()) {\n            return true\n          }\n      }\n      return false\n    }\n}\n","filename":"RootDetectionActivity.kt"}]],"negative":[[{"content":"\npackage no.such.pkg\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport java.io.File\n\nclass RootDetectionActivityNoCall : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // no call to isRooted\n    }\n\n    fun isRooted(): Boolean {\n      val paths =  arrayOf(\"/system/app/Superuser/Superuser.apk\", \"/system/app/Superuser.apk\",\"/sbin/su\", \"/system/bin/su\", \"/system/xbin/su\", \"/data/local/xbin/su\", \"/data/local/bin/su\", \"/system/sd/xbin/su\", \"/system/bin/failsafe/su\", \"/data/local/su\", \"/su/bin/su\", \"re.robv.android.xposed.installer-1.apk\",\"/data/app/eu.chainfire.supersu-1/base.apk\");\n      for(path in paths) {\n          val f = File(path)\n          if (f.exists()) {\n            return true\n          }\n      }\n      return false\n    }\n}\n","filename":"RootDetectionActivityNoCall.kt"},{"content":"\npackage no.such.pkg\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport java.io.File\n\nclass RootDetectionActivityAlwaysFalse : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        if (isRootedNop()) { println(\"Device is rooted\") }\n    }\n\n    fun isRootedNop(): Boolean {\n      val paths = arrayOf(\"/system/app/Superuser/Superuser.apk\", \"/system/app/Superuser.apk\",\"/sbin/su\", \"/system/bin/su\", \"/system/xbin/su\", \"/data/local/xbin/su\", \"/data/local/bin/su\", \"/system/sd/xbin/su\", \"/system/bin/failsafe/su\", \"/data/local/su\", \"/su/bin/su\", \"re.robv.android.xposed.installer-1.apk\",\"/data/app/eu.chainfire.supersu-1/base.apk\");\n      return false\n    }\n}\n","filename":"RootDetectionActivityAlwaysFalse.kt"}]]}},{"name":"copy-loop","author":"@fabsx00","title":"Copy loop detected","description":"\nFor (buf, indices) pairs, determine those inside control structures (for, while, if ...)\nwhere any of the calls made outside of the body (block) are Inc operations. Determine\nthe first argument of that Inc operation and check if they are used as indices for\nthe write operation into the buffer.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.assignment.target.arrayAccess\n          .map { access =>\n            (access.array, access.subscript.code.toSet)\n          }\n          .filter { case (buf, subscripts) =>\n            val incIdentifiers = buf.inAst.isControlStructure.isFor.astChildren\n              .filterNot(_.isBlock)\n              .assignment\n              .target\n              .code\n              .toSet\n            (incIdentifiers & subscripts).nonEmpty\n          }\n          .map(_._1)","tags":["default"],"language":"c","codeExamples":{"positive":["\n\nint index_into_dst_array (char *dst, char *src, int offset) {\n  for(i = 0; i < strlen(src); i++) {\n    dst[i + + j*8 + offset] = src[i];\n  }\n}\n\n"],"negative":["\n\n// We do not want to detect this one because the\n// index only specifies where to read from\nint index_into_src_array() {\n  for(i = 0; i < strlen(src); i++) {\n    dst[k] = src[i];\n  }\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"intent-to-runtime-exec","author":"@ursachec","title":"Data from an intent reaches `Runtime.getRuntime.exec`.","description":"-","score":9.0,"traversal":{},"traversalAsString":"cpg =>\n        import io.shiftleft.semanticcpg.language.android._\n        val exportedActivityNames = cpg.configFile.exportedAndroidActivityNames.l\n        def exportedActivities =\n          cpg.typeDecl.filter { node => exportedActivityNames.contains(node.name) }\n        def getIntentCalls =\n          exportedActivities.method.call.name(\"getIntent\").typeFullName(\"android.content.Intent\")\n        def runtimeExecCalls =\n          cpg.call.name(\"exec\").typeFullName(\"java.lang.Process\")\n        runtimeExecCalls.where(_.argument.reachableBy(getIntentCalls)).l","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"package no.such.pkg;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\nimport java.io.IOException;\n\npublic class DeepLinkActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = getIntent();\n        Uri uri;\n        if(intent != null && Intent.ACTION_VIEW.equals(intent.getAction()) && (uri = intent.getData()) != null) {\n            processDeeplink(uri);\n        }\n        finish();\n    }\n\n    private void processDeeplink(Uri uri) {\n        if(\"http\".equals(uri.getScheme()) && \"java.vroooom.io\".equals(uri.getHost())) {\n            String path = uri.getPath();\n            String secret = uri.getQueryParameter(\"secret\");\n            if(\"/cmdrun\".equals(path) && secret.equals(\"b4dc0ffee\")) {\n                String cmd = uri.getQueryParameter(\"cmd\");\n                String[] cmdArray = new String[3];\n                cmdArray[0] = \"sh\";\n                cmdArray[1] = \"-c\";\n                cmdArray[2] = cmd;\n                try {\n                    Runtime.getRuntime().exec(cmdArray);\n                } catch (IOException e) {\n                    System.out.print(\"error\");\n                }\n            }\n        }\n    }\n}\n","filename":"DeepLinkActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n\n        <activity android:name=\"DeepLinkActivity\" android:exported=\"true\">\n            <intent-filter android:autoVerify=\"true\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n                <data android:host=\"vulnerable\" android:scheme=\"vroooom\" />\n                <data android:scheme=\"http\" />\n                <data android:scheme=\"https\" />\n                <data android:host=\"java.vroooom.io\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]],"negative":[[{"content":"package no.such.pkg;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\nimport java.io.IOException;\n\npublic class DeepLinkActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = getIntent();\n        Uri uri;\n        if(intent != null && Intent.ACTION_VIEW.equals(intent.getAction()) && (uri = intent.getData()) != null) {\n            processDeeplink(uri);\n        }\n        finish();\n    }\n\n    private void processDeeplink(Uri uri) {\n        if(\"http\".equals(uri.getScheme()) && \"java.vroooom.io\".equals(uri.getHost())) {\n            String path = uri.getPath();\n            String secret = uri.getQueryParameter(\"secret\");\n            if(\"/cmdrun\".equals(path) && secret.equals(\"b4dc0ffee\")) {\n                String cmd = uri.getQueryParameter(\"cmd\");\n                String[] cmdArray = new String[3];\n                cmdArray[0] = \"sh\";\n                cmdArray[1] = \"-c\";\n                cmdArray[2] = cmd;\n                try {\n                    Runtime.getRuntime().exec(cmdArray);\n                } catch (IOException e) {\n                    System.out.print(\"error\");\n                }\n            }\n        }\n    }\n}\n","filename":"DeepLinkActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package no.such.pkg;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\nimport java.io.IOException;\n\npublic class DeepLinkActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = getIntent();\n        // no call to processDeeplink\n        finish();\n    }\n\n    private void processDeeplink(Uri uri) {\n        if(\"http\".equals(uri.getScheme()) && \"java.vroooom.io\".equals(uri.getHost())) {\n            String path = uri.getPath();\n            String secret = uri.getQueryParameter(\"secret\");\n            if(\"/cmdrun\".equals(path) && secret.equals(\"b4dc0ffee\")) {\n                String cmd = uri.getQueryParameter(\"cmd\");\n                String[] cmdArray = new String[3];\n                cmdArray[0] = \"sh\";\n                cmdArray[1] = \"-c\";\n                cmdArray[2] = cmd;\n                try {\n                    Runtime.getRuntime().exec(cmdArray);\n                } catch (IOException e) {\n                    System.out.print(\"error\");\n                }\n            }\n        }\n    }\n}\n","filename":"DeepLinkActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n\n        <activity android:name=\"DeepLinkActivity\" android:exported=\"true\">\n            <intent-filter android:autoVerify=\"true\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n                <data android:host=\"vulnerable\" android:scheme=\"vroooom\" />\n                <data android:scheme=\"http\" />\n                <data android:scheme=\"https\" />\n                <data android:host=\"java.vroooom.io\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package no.such.pkg;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\nimport java.io.IOException;\n\npublic class DeepLinkActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = getIntent();\n        Uri uri;\n        if(intent != null && Intent.ACTION_VIEW.equals(intent.getAction()) && (uri = intent.getData()) != null) {\n            processDeeplink(uri);\n        }\n        finish();\n    }\n\n    private void processDeeplink(Uri uri) {\n        if(\"http\".equals(uri.getScheme()) && \"java.vroooom.io\".equals(uri.getHost())) {\n            String path = uri.getPath();\n            String secret = uri.getQueryParameter(\"secret\");\n            if(\"/cmdrun\".equals(path) && secret.equals(\"b4dc0ffee\")) {\n                String cmd = uri.getQueryParameter(\"cmd\");\n                String[] cmdArray = new String[3];\n                cmdArray[0] = \"sh\";\n                cmdArray[1] = \"-c\";\n                cmdArray[2] = cmd;\n                try {\n                    // no call to exec here...\n                    System.out.println(cmdArray);\n                } catch (IOException e) {\n                    System.out.print(\"error\");\n                }\n            }\n        }\n    }\n}\n","filename":"DeepLinkActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.app.lib_name\"\n                android:value=\"\" />\n        </activity>\n\n        <activity android:name=\"DeepLinkActivity\" android:exported=\"true\">\n            <intent-filter android:autoVerify=\"true\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n                <data android:host=\"vulnerable\" android:scheme=\"vroooom\" />\n                <data android:scheme=\"http\" />\n                <data android:scheme=\"https\" />\n                <data android:host=\"java.vroooom.io\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]]}},{"name":"format-controlled-printf","author":"@tuxology","title":"Non-constant format string passed to printf/sprintf/vsprintf","description":"\n Avoid user controlled format strings like \"argv\" in printf, sprintf and vsprintf \n functions as they can cause memory corruption. Some secure\n alternatives are `snprintf` and `vsnprintf`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val printfFns = cpg\n          .method(\"(?i)printf\")\n          .callIn\n          .whereNot(_.argument.order(1).isLiteral)\n        val sprintsFns = cpg\n          .method(\"(?i)(sprintf|vsprintf)\")\n          .callIn\n          .whereNot(_.argument.order(2).isLiteral)\n        printfFns ++ sprintsFns","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\nint insecure_printf() {\n  printf(argv[1], 4242);\n\n}\n","\n\nint insecure_sprintf() {\n  char buffer [BUFF_SIZE];\n  sprintf(buffer, argv[2], 4242);\n}\n\n"],"negative":["\n\nint secure_printf() {\n  printf(\"Num: %d\", 4242);\n}\n\n","\n\nint secure_sprintf() {\n  char buffer [BUFF_SIZE];\n  snprintf(buffer, BUFF_SIZE, argv[2], 4242);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-strcpy","author":"@tuxology","title":"Dangerous functions `strcpy` or `strncpy` used","description":"\n Avoid `strcpy` or `strncpy` function. `strcpy` does not check buffer\n lengths.\n A possible mitigation could be `strncpy` which could prevent\n buffer overflows but does not null-terminate strings leading to\n memory corruption. A secure alternative (on BSD) is `strlcpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)(strcpy|strncpy)\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nvoid insecure_strcpy(char *dest, char *src) {\n    strcpy(dest, src);\n}\n\n","\n\nint insecure_strncpy() {\n  char buf[BUF_SIZE];\n  strncpy(buf, default_value, BUF_SIZE); // remediation is (BUFF_SIZE - 1)\n  return 0\n}\n\n"],"negative":["\n\nvoid secure_strlcpy(char *dest, char *src, size_t size) {\n    strlcpy(dest, src, size);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-gets","author":"@tuxology","title":"Dangerous function gets() used","description":"\n Avoid `gets` function as it can lead to reads beyond buffer\n boundary and cause\n buffer overflows. Some secure alternatives are `fgets` and `gets_s`.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)gets\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_gets() {\n  char str[DST_BUFFER_SIZE];\n  gets(str);\n  printf(\"%s\", str);\n  return 0;\n}\n\n"],"negative":["\n\nint secure_gets() {\n  FILE *fp;\n  fp = fopen(\"file.txt\" , \"r\");\n  char str[DST_BUFFER_SIZE];\n  fgets(str, DST_BUFFER_SIZE, fp);\n  printf(\"%s\", str);\n  return 0;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-scanf","author":"@tuxology","title":"Insecure function scanf() used","description":"\n Avoid `scanf` function as it can lead to reads beyond buffer\n boundary and cause buffer overflows. A secure alternative is `fgets`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)scanf\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nint insecure_scanf() {\n  char name[12];\n  scanf(\"%s\", name);\n  printf(\"Hello %s!\\n\", name);\n  return 0\n}\n\n"],"negative":["\n\nvoid secure_fgets(char *buf, int size, FILE *stream) {\n    fgets(buf, size, stream);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-strcat","author":"@tuxology","title":"Dangerous functions `strcat` or `strncat` used","description":"\n Avoid `strcat` or `strncat` functions. These can be used insecurely\n causing non null-termianted strings leading to memory corruption.\n A secure alternative is `strcat_s`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)(strcat|strncat)\").callIn","tags":["badfn"],"language":"c","codeExamples":{"positive":["\n\nvoid insecure_strcat(char *dest, char *src) {\n    strcat(dest, src);\n}\n\n","\n\nint insecure_strncat() {\n  char buf[BUF_SIZE];\n  strncat(buf, another_buffer, BUF_SIZE - strlen(buf)); // remediation is (BUFF_SIZE - strlen(buf) - 1)\n  return 0\n}\n\n"],"negative":["\n\nvoid secure_strcat_s(char *dest, rsize_t destsz, char *src) {\n    strcat_s(dest, destsz, src);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-strtok","author":"@tuxology","title":"Dangerous function strtok() used","description":"\n Avoid `strtok` function as it modifies the original string in place\n and appends a null character after each token. This makes the\n original string unsafe. Suggested alternative is `strtok_r` with\n `saveptr`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)strtok\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_strtok() {\n  char *token;\n  char *path = getenv(\"PATH\");\n  token = strtok(path, \":\");\n  puts(token);\n  printf(\"PATH: %s\\n\", path); // original path string now has '/usr/bin\\0' now and is insecure to use\n  return 0;\n}\n\n"],"negative":["\n\nvoid secure_strtok_r(char *src, char *delim, char **saveptr) {\n    strtok_r(src, delim, saveptr);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"call-to-getwd","author":"@ursachec","title":"Dangerous function getwd() used","description":"\n Avoid the `getwd` function, it does not check buffer lengths.\n Use `getcwd` instead, as it checks the buffer size.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(?i)getwd\").callIn","tags":["badfn","default"],"language":"c","codeExamples":{"positive":["\n\nint insecure_getwd() {\n  char dir[12];\n  getwd(dir);\n  printf(\"Working directory:%s\\n\",dir);\n  return 0;\n}\n\n"],"negative":["\nvoid secure_getcwd(char *buf, size_t len) {\n    getcwd(buf, len);\n}\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"setuid-without-setgid","author":"@maltek","title":"Process user ID is changed without changing groups first","description":"\nThe set*uid system calls do not affect the groups a process belongs to. However, often\nthere exists a group that is equivalent to a user (e.g. wheel or shadow groups are often\nequivalent to the root user).\nGroup membership can only be changed by the root user.\nChanges to the user should therefore always be preceded by calls to set*gid and setgroups,\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"(?i)set(res|re|e|)uid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"set(res|re|e|)?gid\"))","tags":["setxid","default"],"language":"c","codeExamples":{"positive":["\n\nvoid bad1() {\n  setresuid();\n}\n\nvoid bad3() {\n  setgroups();\n  setresuid();\n}\n\n"],"negative":["\n\nvoid good() {\n  setgroups();\n  setresgid();\n  setresuid();\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"setgid-without-setgroups","author":"@maltek","title":"Process group membership is changed without setting ancillary groups first","description":"\nThe set*gid system calls do not affect the ancillary groups a process belongs to.\nChanges to the group membership should therefore always be preceded by a call to setgroups.\nOtherwise the process may still be a secondary member of the group it tries to disavow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"(?i)set(res|re|e|)gid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"setgroups\"))","tags":["setxid","default"],"language":"c","codeExamples":{"positive":["\n\nvoid bad2() {\n  setresgid();\n  setresuid();\n}\n\n"],"negative":["\n\nvoid good() {\n  setgroups();\n  setresgid();\n  setresuid();\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"broadcast-to-file-write","author":"@ursachec","title":"Data from a broadcast ends up in a file write operation.","description":"-","score":6.0,"traversal":{},"traversalAsString":"cpg =>\n        import io.shiftleft.semanticcpg.language.android._\n        def exposedBroadcastReceivers =\n          cpg.registeredBroadcastReceivers.filter { receiver =>\n            cpg.appManifest.exportedBroadcastReceiverNames.exists(receiver.name == _)\n          }\n        def exposedBroadcastReceiverData =\n          exposedBroadcastReceivers.method.nameExact(\"onReceive\").parameter.index(2)\n        def fileWriteCalls =\n          cpg.call.nameExact(\"write\").where(_.argument.isIdentifier.typeFullNameExact(\"java.io.FileOutputStream\"))\n        fileWriteCalls.where(_.argument.reachableBy(exposedBroadcastReceiverData))","tags":["android"],"language":"android","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[[{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class WriteFileBroadcastReceiver extends BroadcastReceiver {\n    public WriteFileBroadcastReceiver() {}\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String fileNameFromBroadcast = intent.getStringExtra(\"filename\");\n        String contentFromBroadcast = intent.getStringExtra(\"content\");\n        try {\n            String filePath = context.getFilesDir().toString() + fileNameFromBroadcast;\n            FileOutputStream outputStream = new FileOutputStream(filePath);\n            byte[] strToBytes = contentFromBroadcast.getBytes();\n            outputStream.write(strToBytes);\n            outputStream.close();\n            Log.d(\"WriteFileBroadcastReceiver\", \"filePath: \" + filePath);\n            Log.d(\"WriteFileBroadcastReceiver\", \"content: \" + contentFromBroadcast);\n        } catch (IOException ex) {\n            Log.d(\"exception\", ex.getLocalizedMessage());\n        }\n    }\n}\n","filename":"io/vrooom/vulnerableapp/WriteFileBroadcastReceiver.java"},{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(getPackageName() + \"io.vrooom.intent.action.WRITE_FILE\");\n        WriteFileBroadcastReceiver myReceiver = new WriteFileBroadcastReceiver();\n        registerReceiver(myReceiver, filter);\n    }\n}\n","filename":"io/vrooom/vulnerableapp/MainActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        android:requestLegacyExternalStorage=\"true\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <receiver android:name=\".WriteFileBroadcastReceiver\" android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"io.vrooom.intent.action.WRITE_FILE\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package io.vrooom.vulnerableapp\n\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.nio.charset.Charset\n\nclass WriteFileBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        val fileNameFromBroadcast = intent!!.getStringExtra(\"filename\")\n        val contentFromBroadcast = intent!!.getStringExtra(\"content\")\n        try {\n            val filePath = context!!.filesDir.toString() + fileNameFromBroadcast\n            val outputStream: FileOutputStream = FileOutputStream(filePath)\n            val strToBytes = contentFromBroadcast!!.toByteArray(Charset.defaultCharset())\n            outputStream.write(strToBytes)\n            outputStream.close()\n            Log.d(\"WriteFileBroadcastReceiver\", \"filePath: \" + filePath)\n            Log.d(\"WriteFileBroadcastReceiver\", \"content: \" + contentFromBroadcast)\n        } catch (ex: IOException) {\n            Log.d(\"exception\", ex.getLocalizedMessage())\n        }\n    }\n}\n","filename":"WriteFileBroadcastReceiver.kt"},{"content":"package io.vrooom.vulnerableapp\n\nimport android.os.Bundle\nimport android.support.v7.app.AppCompatActivity\nimport android.webkit.WebView\nimport android.content.IntentFilter\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val filter: IntentFilter = IntentFilter()\n        filter.addAction(packageName + \"io.vrooom.intent.action.WRITE_FILE\")\n        val receiver = WriteFileBroadcastReceiver()\n        registerReceiver(receiver, filter)\n    }\n}\n","filename":"MainActivity.kt"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        android:requestLegacyExternalStorage=\"true\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <receiver android:name=\".WriteFileBroadcastReceiver\" android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"io.vrooom.intent.action.WRITE_FILE\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]],"negative":[[{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class WriteFileBroadcastReceiver extends BroadcastReceiver {\n    public WriteFileBroadcastReceiver() {}\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String fileNameFromBroadcast = intent.getStringExtra(\"filename\");\n        String contentFromBroadcast = intent.getStringExtra(\"content\");\n        try {\n            String filePath = context.getFilesDir().toString() + fileNameFromBroadcast;\n            FileOutputStream outputStream = new FileOutputStream(filePath);\n            byte[] strToBytes = contentFromBroadcast.getBytes();\n            outputStream.write(strToBytes);\n            outputStream.close();\n            Log.d(\"WriteFileBroadcastReceiver\", \"filePath: \" + filePath);\n            Log.d(\"WriteFileBroadcastReceiver\", \"content: \" + contentFromBroadcast);\n        } catch (IOException ex) {\n            Log.d(\"exception\", ex.getLocalizedMessage());\n        }\n    }\n}\n","filename":"io/vrooom/vulnerableapp/WriteFileBroadcastReceiver.java"},{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(getPackageName() + \"io.vrooom.intent.action.WRITE_FILE\");\n        WriteFileBroadcastReceiver myReceiver = new WriteFileBroadcastReceiver();\n        // no call to registerReceiver here\n    }\n}\n","filename":"io/vrooom/vulnerableapp/MainActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        android:requestLegacyExternalStorage=\"true\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <receiver android:name=\".WriteFileBroadcastReceiver\" android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"io.vrooom.intent.action.WRITE_FILE\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}],[{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class WriteFileBroadcastReceiver extends BroadcastReceiver {\n    public WriteFileBroadcastReceiver() {}\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String fileNameFromBroadcast = intent.getStringExtra(\"filename\");\n        String contentFromBroadcast = intent.getStringExtra(\"content\");\n        try {\n            String filePath = context.getFilesDir().toString() + fileNameFromBroadcast;\n            FileOutputStream outputStream = new FileOutputStream(filePath);\n            byte[] strToBytes = contentFromBroadcast.getBytes();\n            // no call to `outputStream.write` here\n            outputStream.close();\n            Log.d(\"WriteFileBroadcastReceiver\", \"filePath: \" + filePath);\n            Log.d(\"WriteFileBroadcastReceiver\", \"content: \" + contentFromBroadcast);\n        } catch (IOException ex) {\n            Log.d(\"exception\", ex.getLocalizedMessage());\n        }\n    }\n}\n","filename":"io/vrooom/vulnerableapp/WriteFileBroadcastReceiver.java"},{"content":"package io.vrooom.vulnerableapp;\n\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.webkit.WebView;\n\npublic class MainActivityJava extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(getPackageName() + \"io.vrooom.intent.action.WRITE_FILE\");\n        WriteFileBroadcastReceiver myReceiver = new WriteFileBroadcastReceiver();\n        registerReceiver(myReceiver, filter);\n    }\n}\n","filename":"io/vrooom/vulnerableapp/MainActivity.java"},{"content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:usesCleartextTraffic=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Vulnerableapp\"\n        android:requestLegacyExternalStorage=\"true\"\n        tools:targetApi=\"31\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <receiver android:name=\".WriteFileBroadcastReceiver\" android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"io.vrooom.intent.action.WRITE_FILE\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n","filename":"AndroidManifest.xml"}]]}},{"name":"usage-of-insecure-protocol","author":"@ursachec","title":"Insecure Protocol used","description":"\nUsing insecure network protocols allows attackers who control the network to replace, remove and inject data.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .fullNameExact(\"java.net.URL.<init>:void(java.lang.String)\")\n          .callIn\n          .where(_.argument.isLiteral.code(\"^[^h]*http:.*\"))\n          .l","tags":["insecure-network-traffic","android"],"language":"kotlin","codeExamples":{"positive":["\nimport java.io.BufferedReader; import java.io.InputStreamReader; import java.net.URL;\nfun fn1() {\n    val url = URL(\"http://phrack.org\") // <---- relevant line\n    val connection = url.openConnection()\n    BufferedReader(InputStreamReader(connection.getInputStream())).use { inp ->\n        var line: String?\n        while (inp.readLine().also { line = it } != null) {\n            println(line)\n        }\n    }\n}\n"],"negative":["\nimport java.io.BufferedReader; import java.io.InputStreamReader; import java.net.URL;\nfun fn2() {\n    val url = URL(\"https://phrack.org\") // <---- relevant line\n    val connection = url.openConnection()\n    BufferedReader(InputStreamReader(connection.getInputStream())).use { inp ->\n        var line: String?\n        while (inp.readLine().also { line = it } != null) {\n            println(line)\n        }\n    }\n}\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"getenv-to-strcpy","author":"@ursachec","title":"`getenv` fn arguments used in strcpy source buffer","description":"\nUser-input ends up in source buffer argument of strcpy, which might overflow the destination buffer.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        def source =\n          cpg.call.methodFullName(\"getenv\").cfgNext.isCall.argument(2)\n        def sink = cpg.method.fullName(\"strcpy\").parameter.index(2)\n        sink.reachableBy(source).l","tags":["badfn"],"language":"ghidra","codeExamples":{"positive":[],"negative":[]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"intent-redirection","author":"@ursachec","title":"Intent redirected without validation","description":"-","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .nameExact(\"getParcelableExtra\")\n          .callIn\n          .code(\".*Intent.*\")\n          .filter { c =>\n            def startActivityCalls = cpg.method.nameExact(\"startActivity\").callIn\n            def sink               = startActivityCalls.whereNot(_.controlledBy.astParent.isControlStructure).argument\n            sink.reachableByFlows(c).nonEmpty\n          }\n          .l","tags":["android"],"language":"android","codeExamples":{"positive":["\nfun matchingExample1() {\n    val forwardIntent = intent.getParcelableExtra<Intent>(\"very_forward_of_you\")\n    startActivity(forwardIntent)\n}\n"],"negative":["\nfun nonMatchingExample1() {\n    val forwardIntent = intent.getParcelableExtra<Intent>(\"very_forward_of_you\")\n    val destinationComponent = forwardIntent!!.resolveActivity(packageManager)\n    if (destinationComponent.packageName.equals(\"org.emotet.botnet.safe\") &&\n        destinationComponent.className.equals(\"TotallySafeClass\")) {\n        startActivity(forwardIntent)\n    }\n}\n","\nfun nonMatchingExample2() {\n    val forwardIntent = intent.getParcelableExtra<Intent>(\"very_forward_of_you\")\n    val destinationComponent = forwardIntent!!.resolveActivity(packageManager)\n    if (destinationComponent.packageName.equals(\"org.emotet.botnet.safe\") &&\n        destinationComponent.className.equals(\"TotallySafeClass\")) {\n        startActivity(forwardIntent)\n    }\n}\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"free-field-no-reassign","author":"@fabsx00","title":"A field of a parameter is free'd and not reassigned on all paths","description":"\n The function is able to modify a field of a structure passed in by\n the caller. It frees this field and does not guarantee that on\n all paths to the exit, the field is reassigned. If any\n caller now accesses the field, then it accesses memory that is no\n longer allocated. We also check that the function does not free\n or clear the entire structure, as in that case, it is unlikely that the\n passed in structure will be used again.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        val freeOfStructField = cpg\n          .method(\"free\")\n          .callIn\n          .where(\n            _.argument(1)\n              .isCallTo(\"<operator>.*[fF]ieldAccess.*\")\n              .filter(x => x.method.parameter.name.toSet.contains(x.argument(1).code))\n          )\n          .whereNot(_.argument(1).isCall.argument(1).filter { struct =>\n            struct.method.ast.isCall\n              .name(\".*free$\", \"memset\", \"bzero\")\n              .argument(1)\n              .codeExact(struct.code)\n              .nonEmpty\n          })\n          .l\n\n        freeOfStructField.argument(1).filter { arg =>\n          arg.method.methodReturn.reachableBy(arg).nonEmpty\n        }","tags":["uaf","default"],"language":"c","codeExamples":{"positive":["\n\nvoid free_field_reassigned(a_struct_type *a_struct) {\n  free(a_struct->ptr);\n  if (something) {\n    return;\n  }\n  a_struct->ptr = foo;\n}\n\n"],"negative":["\n\nvoid not_free_field_reassigned(a_struct_type *a_struct) {\n  free(a_struct->ptr);\n  if (something) {\n    a_struct->ptr = NULL;\n    return;\n  }\n  a_struct->ptr = foo;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"free-returned-value","author":"@maltek","title":"A value that is returned through a parameter is free'd in a path","description":"\nThe function sets a field of a function parameter to a value of a local\nvariable.\nThis variable is then freed in some paths. Unless the value set in the\nfunction parameter is overridden later on, the caller has access to the\nfree'd memory, which is undefined behavior.\n\nFinds bugs like CVE-2019-18902.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        def outParams =\n          cpg.parameter\n            .code(\".+\\\\*.+\")\n            .whereNot(\n              _.referencingIdentifiers\n                .argumentIndex(1)\n                .inCall\n                .nameExact(Operators.assignment, Operators.addressOf)\n            )\n\n        def assignedValues =\n          outParams.referencingIdentifiers\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.indirectFieldAccess, Operators.indirection, Operators.indirectIndexAccess)\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.assignment)\n            .argument(2)\n            .isIdentifier\n\n        def freeAssigned =\n          assignedValues.map(id =>\n            (\n              id,\n              id.refsTo\n                .flatMap {\n                  case p: MethodParameterIn => p.referencingIdentifiers\n                  case v: Local             => v.referencingIdentifiers\n                }\n                .inCall\n                .name(\"(.*_)?free\")\n            )\n          )\n\n        freeAssigned\n          .filter { case (id, freeCall) =>\n            freeCall.dominatedBy.exists(_ == id)\n          }\n          .flatMap(_._1)","tags":["uaf"],"language":"c","codeExamples":{"positive":["\n\nvoid bad(a_struct_type *a_struct) {\n  void *x = NULL;\n  a_struct->foo = x;\n  free(x);\n}\n\n"],"negative":["\n\nvoid good1(a_struct_type *a_struct) {\n  void *x = NULL, *y = NULL;\n  a_struct->foo = x;\n  free(y);\n}\n\nvoid good2(a_struct_type *a_struct) {\n  void *x = NULL;\n  free(a_struct->foo);\n  a_struct->foo = x;\n}\n\nvoid bad_not_covered(a_struct_type *a_struct) {\n  void *x = NULL;\n  a_struct->foo = x;\n  free(a_struct->foo);\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}},{"name":"free-follows-value-reuse","author":"@maltek","title":"A value that is free'd is reused without reassignment.","description":"\nA value is used after being free'd in a path that leads to it\nwithout reassignment.\n\nModeled after CVE-2019-18903.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .name(\"(.*_)?free\")\n          .filter(_.parameter.size == 1)\n          .callIn\n          .where(_.argument(1).isIdentifier)\n          .flatMap(f => {\n            val freedIdentifierCode = f.argument(1).code\n            val postDom             = f.postDominatedBy.toSetImmutable\n\n            val assignedPostDom = postDom.isIdentifier\n              .where(_.inAssignment)\n              .codeExact(freedIdentifierCode)\n              .flatMap(id => Traversal.fromSingle(id) ++ id.postDominatedBy)\n\n            postDom\n              .removedAll(assignedPostDom)\n              .isIdentifier\n              .codeExact(freedIdentifierCode)\n          })","tags":["uaf"],"language":"c","codeExamples":{"positive":["\n\nvoid *bad() {\n  void *x = NULL;\n  if (cond)\n    free(x);\n  return x;\n}\n\nvoid *false_positive() {\n  void *x = NULL;\n  free(x);\n  if (cond)\n    x = NULL;\n  else\n    x = NULL;\n  return x;\n}\n\n"],"negative":["\n\nvoid *false_negative() {\n  void *x = NULL;\n  if (cond) {\n    free(x);\n    if (cond2)\n      return x; // not post-dominated by free call\n    x = NULL;\n  }\n  return x;\n}\n\nvoid *good() {\n  void *x = NULL;\n  if (cond)\n    free(x);\n  x = NULL;\n  return x;\n}\n\n"]},"multiFileCodeExamples":{"positive":[],"negative":[]}}]